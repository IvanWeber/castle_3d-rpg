<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D RPG с надёжными прыжками</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.5); color: white;
      padding: 10px; font-family: sans-serif;
      max-width: 400px; border-radius: 8px;
    }
    #dialogue { margin-top: 10px; }
    .choice { padding: 4px 6px; }
    .selected { background: rgba(255,255,255,0.3); }
  </style>
</head>
<body>
  <div id="ui">
    <div>Золото: <span id="gold">0</span></div>
    <div>Инвентарь: <span id="inv">пусто</span></div>
    <div id="dialogue"></div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const goldEl = document.getElementById("gold");
    const invEl = document.getElementById("inv");
    const dialogueEl = document.getElementById("dialogue");

    let gold = 0;
    let inventory = [];
    let isTalking = false;
    let currentChoices = [];
    let currentCallback = null;
    let selectedIndex = 0;

    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    let yaw = 0, pitch = 0;
    document.body.addEventListener("click", () => {
      if (document.pointerLockElement !== renderer.domElement)
        renderer.domElement.requestPointerLock();
    });
    document.addEventListener("mousemove", e => {
      if (document.pointerLockElement === renderer.domElement) {
        yaw -= e.movementX * 0.002;
        pitch += e.movementY * 0.002;
        pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitch));
      }
    });

    const player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color: 0x4444ff }));
    player.position.set(0, 1, 0);
    scene.add(player);

    const floor = new THREE.Mesh(new THREE.BoxGeometry(100, 1, 100), new THREE.MeshBasicMaterial({ color: 0x228822 }));
    floor.position.y = -0.5; // чтобы верхняя грань была на y = 0
    scene.add(floor);

    // Платформа
    const platform = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 6), new THREE.MeshBasicMaterial({ color: 0x8888ff }));
    platform.position.set(0, 2, 5); // верхняя грань на 2.5
    scene.add(platform);

    const obstacles = [floor, platform];

    // Прыжковая физика
    let velocityY = 0;
    let isOnGround = false;
    const gravity = -0.02;
    const jumpStrength = 0.35;

    document.addEventListener("keydown", e => {
      if (e.key === " " && isOnGround && !isTalking) {
        velocityY = jumpStrength;
        isOnGround = false;
      }
    });

    function aabb(boxA, boxB) {
      return (
        boxA.max.x > boxB.min.x &&
        boxA.min.x < boxB.max.x &&
        boxA.max.y > boxB.min.y &&
        boxA.min.y < boxB.max.y &&
        boxA.max.z > boxB.min.z &&
        boxA.min.z < boxB.max.z
      );
    }

    function getPlayerBox(pos) {
      const size = new THREE.Vector3(1, 2, 1);
      return new THREE.Box3().setFromCenterAndSize(pos, size);
    }

    function collides(pos) {
      const box = getPlayerBox(pos);
      return obstacles.some(obj => {
        const other = new THREE.Box3().setFromObject(obj);
        return aabb(box, other);
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
      const speed = 0.15;

      let moveX = 0, moveZ = 0;
      if (keys["w"]) { moveX += dir.x; moveZ += dir.z; }
      if (keys["s"]) { moveX -= dir.x; moveZ -= dir.z; }
      if (keys["a"]) { moveX -= right.x; moveZ -= right.z; }
      if (keys["d"]) { moveX += right.x; moveZ += right.z; }

      const move = new THREE.Vector3(moveX, 0, moveZ).normalize().multiplyScalar(speed);
      const pos = player.position.clone();

      // X движение
      const nextX = pos.clone().add(new THREE.Vector3(move.x, 0, 0));
      if (!collides(nextX)) player.position.x = nextX.x;

      // Z движение
      const nextZ = player.position.clone().add(new THREE.Vector3(0, 0, move.z));
      if (!collides(nextZ)) player.position.z = nextZ.z;

      // Y движение (гравитация и прыжок)
      velocityY += gravity;
      const nextY = player.position.clone().add(new THREE.Vector3(0, velocityY, 0));
      if (!collides(nextY)) {
        player.position.y = nextY.y;
        isOnGround = false;
      } else {
        // Если падали — считаем, что стоим на чём-то
        if (velocityY < 0) isOnGround = true;
        velocityY = 0;
      }

      player.rotation.y = yaw;

      // Камера
      const camX = player.position.x - Math.sin(yaw) * 5;
      const camY = player.position.y + 2 + Math.sin(pitch) * 5;
      const camZ = player.position.z - Math.cos(yaw) * 5;
      camera.position.set(camX, camY, camZ);
      camera.lookAt(player.position);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
