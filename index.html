<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>3D RPG с замком и Пердунчиком</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      color: white;
      font-family: sans-serif;
      max-width: 400px;
      border-radius: 8px;
    }
    #dialogue { margin-top: 10px; }
    .choice { padding: 4px 6px; }
    .selected { background: rgba(255,255,255,0.3); }
  </style>
</head>
<body>
  <div id="ui">
    <div>Золото: <span id="gold">0</span></div>
    <div>Инвентарь: <span id="inv">пусто</span></div>
    <div id="dialogue"></div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // Основные переменные
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // UI
    const goldEl = document.getElementById("gold");
    const invEl = document.getElementById("inv");
    const dialogueEl = document.getElementById("dialogue");

    let gold = 0;
    let inventory = [];
    let isTalking = false;
    let currentChoices = [];
    let currentCallback = null;
    let selectedIndex = 0;

    function updateUI() {
      goldEl.textContent = gold;
      invEl.textContent = inventory.join(", ") || "пусто";
    }

    function showDialogue(text, choices = [], callback = null) {
      isTalking = true;
      selectedIndex = 0;
      currentChoices = choices;
      currentCallback = callback;
      dialogueEl.innerHTML = `<div>${text}</div>` + choices.map((c, i) =>
        `<div class="choice${i === 0 ? ' selected' : ''}">${c}</div>`
      ).join("");
    }

    function updateChoicesUI() {
      const elems = dialogueEl.querySelectorAll(".choice");
      elems.forEach((el, i) => {
        el.className = "choice" + (i === selectedIndex ? " selected" : "");
      });
    }

    function closeDialogue() {
      isTalking = false;
      currentChoices = [];
      currentCallback = null;
      dialogueEl.innerHTML = "";
    }

    // Пол
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0x228822 }));
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Игрок
    const player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color: 0x4444ff }));
    player.position.y = 1;
    scene.add(player);

    const sword = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.2), new THREE.MeshBasicMaterial({ color: 0xcccccc }));
    sword.position.set(0.5, 1, 0);
    sword.visible = false;
    player.add(sword);

    // Враг
    const enemy = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
    enemy.position.set(0, 1, -10);
    scene.add(enemy);
    let enemyAlive = true;

    // Камера и мышь
    let yaw = 0, pitch = 0;
    document.body.addEventListener("click", () => {
      if (document.pointerLockElement !== renderer.domElement)
        renderer.domElement.requestPointerLock();
    });
    document.addEventListener("mousemove", e => {
      if (document.pointerLockElement === renderer.domElement) {
        yaw -= e.movementX * 0.002;
        pitch += e.movementY * 0.002;
        pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitch));
      }
    });

    // Управление
    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    document.addEventListener("keydown", e => {
      if (isTalking) {
        if (["w", "a", "arrowup"].includes(e.key.toLowerCase())) {
          selectedIndex = (selectedIndex - 1 + currentChoices.length) % currentChoices.length;
          updateChoicesUI();
        }
        if (["s", "d", "arrowdown"].includes(e.key.toLowerCase())) {
          selectedIndex = (selectedIndex + 1) % currentChoices.length;
          updateChoicesUI();
        }
        if (e.key === "Enter") {
          const choice = currentChoices[selectedIndex];
          if (currentCallback) currentCallback(choice);
          closeDialogue();
        }
      } else {
        if (e.key.toLowerCase() === "e") {
          const npc = npcs.find(n => n.position.distanceTo(player.position) < 2.5);
          if (npc) npc.userData.talk();
        }
        if (e.key.toLowerCase() === "i") {
          if (inventory.includes("Меч")) sword.visible = true;
        }
        if (e.key === " ") attack();
      }
    });

    // Атака
    let isAttacking = false;
    let attackTimer = 0;
    function attack() {
      if (!isAttacking) {
        isAttacking = true;
        attackTimer = 0.2;
      }
    }

    // NPC
    const npcs = [];

    function createNPC(x, z, color, talkFn) {
      const npc = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color }));
      npc.position.set(x, 1, z);
      npc.userData.talk = talkFn;
      scene.add(npc);
      npcs.push(npc);
    }

    // Квест и ворота
    let questGiven = false, questComplete = false, gateOpen = false, gate = null;

    createNPC(-5, 0, 0xffff00, () => {
      if (!questGiven) {
        showDialogue("Привет, убей монстра!", ["Взять квест", "Позже"], choice => {
          if (choice === "Взять квест") questGiven = true;
        });
      } else if (questComplete) {
        showDialogue("Молодец! Открываю ворота!", ["Спасибо"], () => {
          gold += 20;
          updateUI();
          openGate();
          questGiven = questComplete = false;
        });
      } else {
        showDialogue("Монстр ещё жив!");
      }
    });

    createNPC(5, 0, 0xff8800, () => {
      showDialogue("Купи меч за 10 золота?", ["Купить", "Нет"], choice => {
        if (choice === "Купить" && gold >= 10) {
          gold -= 10;
          inventory.push("Меч");
          updateUI();
        }
      });
    });

    // Ворота замка
    function buildCastle() {
      const mat = new THREE.MeshBasicMaterial({ color: 0x777777 });
      const tower = new THREE.BoxGeometry(2, 6, 2);

      const left = new THREE.Mesh(tower, mat);
      left.position.set(-3, 3, 20);
      scene.add(left);

      const right = new THREE.Mesh(tower, mat);
      right.position.set(3, 3, 20);
      scene.add(right);

      gate = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.5), new THREE.MeshBasicMaterial({ color: 0x552200 }));
      gate.position.set(0, 2, 20);
      scene.add(gate);
    }

    function openGate() {
      gateOpen = true;
    }

    buildCastle();

    // === Пердунчик ===
    const fartDude = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0x88ffff }));
    fartDude.position.set(0, 10, 0);
    fartDude.userData.talk = () => {
      showDialogue("ПУУУФ! Это был я. Газ победит зло.", ["Аха-ха!", "Бее..."]);
    };
    scene.add(fartDude);
    npcs.push(fartDude);

    const fartClouds = [], fartGroup = new THREE.Group();
    scene.add(fartGroup);
    const fartGeo = new THREE.SphereGeometry(0.5, 8, 8);
    const fartMat = new THREE.MeshBasicMaterial({ color: 0x88ff88, transparent: true, opacity: 0.7 });
    let fartTimer = 0;

    // Анимация
    function animate() {
      requestAnimationFrame(animate);

      const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();

      if (!isTalking) {
        if (keys["w"]) player.position.addScaledVector(dir, 0.15);
        if (keys["s"]) player.position.addScaledVector(dir, -0.15);
        if (keys["a"]) player.position.addScaledVector(right, -0.15);
        if (keys["d"]) player.position.addScaledVector(right, 0.15);
      }

      if (isAttacking) {
        attackTimer -= 0.016;
        if (attackTimer <= 0) {
          isAttacking = false;
          if (enemyAlive && player.position.distanceTo(enemy.position) < 2) {
            scene.remove(enemy);
            enemyAlive = false;
            inventory.push("Коготь");
            gold += 10;
            updateUI();
            if (questGiven) questComplete = true;
          }
        }
      }

      if (gateOpen && gate && gate.position.y < 10) {
        gate.position.y += 0.1;
      }

      const t = performance.now() * 0.001;
      fartDude.position.set(Math.sin(t) * 10, 8 + Math.sin(t * 2), Math.cos(t) * 10);

      fartTimer -= 0.016;
      if (fartTimer <= 0) {
        const cloud = new THREE.Mesh(fartGeo, fartMat.clone());
        cloud.position.copy(fartDude.position);
        cloud.userData.life = 3.0;
        fartGroup.add(cloud);
        fartClouds.push(cloud);
        fartTimer = 3 + Math.random();
      }

      fartClouds.forEach(c => {
        c.userData.life -= 0.016;
        c.material.opacity = c.userData.life / 3;
        c.position.y += 0.01;
      });
      while (fartClouds.length && fartClouds[0].userData.life <= 0) {
        fartGroup.remove(fartClouds.shift());
      }

      const camX = player.position.x - Math.sin(yaw) * 5;
      const camY = player.position.y + 2 + Math.sin(pitch) * 5;
      const camZ = player.position.z - Math.cos(yaw) * 5;
      camera.position.set(camX, camY, camZ);
      camera.lookAt(player.position);

      renderer.render(scene, camera);
    }

    updateUI();
    animate();
  </script>
</body>
</html>
