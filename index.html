<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D RPG ‚Äî –≤—Å—ë –≤–º–µ—Å—Ç–µ</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.5); color: white;
      padding: 10px; font-family: sans-serif;
      max-width: 400px; border-radius: 8px;
    }
    #dialogue { margin-top: 10px; }
    .choice { padding: 4px 6px; }
    .selected { background: rgba(255,255,255,0.3); }
    #redFlash {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,0,0,0.3);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
  </style>
</head>
<body>
<div id="ui">
  <div>–ó–æ–ª–æ—Ç–æ: <span id="gold">0</span></div>
  <div>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: <span id="inv">–ø—É—Å—Ç–æ</span></div>
  <div id="health">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  <div id="dialogue"></div>
</div>
<div id="redFlash"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1.5);
  light.position.set(-10, 20, 10);
  light.castShadow = true;
  light.shadow.mapSize.set(2048, 2048);
  light.shadow.camera.near = 0.5;
  light.shadow.camera.far = 100;
  light.shadow.camera.left = -50;
  light.shadow.camera.right = 50;
  light.shadow.camera.top = 50;
  light.shadow.camera.bottom = -50;
  scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);

  const goldEl = document.getElementById("gold");
  const invEl = document.getElementById("inv");
  const dialogueEl = document.getElementById("dialogue");
  const healthEl = document.getElementById("health");
  const redFlash = document.getElementById("redFlash");

  let gold = 0;
  let inventory = [];
  let isTalking = false;
  let currentChoices = [];
  let currentCallback = null;
  let selectedIndex = 0;
  let playerHealth = 5;
  const maxHealth = 5;

  const loader = new THREE.TextureLoader();
  const skyTextureBase64 = ``;
  loader.load(skyTextureBase64, texture => {
    const skyGeo = new THREE.SphereGeometry(500, 32, 32);
    const skyMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);
  });

  function createCharacter({ color = 0xaaaaaa, material = null, x = 0, z = 0 }) {
    const group = new THREE.Group();
    group.position.set(x, 0, z);

    const mat = material || new THREE.MeshStandardMaterial({ color });

    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), mat);
    body.position.y = 1.6;
    body.castShadow = true;
    group.add(body);

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mat);
    head.position.y = 2.4;
    head.castShadow = true;
    group.add(head);

    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), mat);
    leftArm.position.set(-0.65, 1.6, 0);
    leftArm.castShadow = true;
    group.add(leftArm);

    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), mat);
    rightArm.position.set(0.65, 1.6, 0);
    rightArm.castShadow = true;
    group.add(rightArm);

    const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), mat);
    leftLeg.position.set(-0.25, 0.5, 0);
    leftLeg.castShadow = true;
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), mat);
    rightLeg.position.set(0.25, 0.5, 0);
    rightLeg.castShadow = true;
    group.add(rightLeg);

    return { group, rightArm };
  }

  const keys = {};
  document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
  document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

  let yaw = 0, pitch = 0;
  document.body.addEventListener("click", () => {
    if (document.pointerLockElement !== renderer.domElement)
      renderer.domElement.requestPointerLock();
  });
  document.addEventListener("mousemove", e => {
    if (document.pointerLockElement === renderer.domElement) {
      yaw -= e.movementX * 0.002;
      pitch += e.movementY * 0.002;
      pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitch));
    }
  });

  function updateUI() {
    goldEl.textContent = gold;
    invEl.textContent = inventory.join(", ") || "–ø—É—Å—Ç–æ";
  }

  function updateHealthUI() {
    const hearts = "‚ù§Ô∏è".repeat(playerHealth) + "üñ§".repeat(maxHealth - playerHealth);
    healthEl.textContent = hearts;
  }

  const matPlayer = new THREE.MeshStandardMaterial({ color: 0x4444ff });
  const playerParts = createCharacter({ material: matPlayer });
  const player = playerParts.group;
  const playerRightArm = playerParts.rightArm;
  player.position.set(0, 0, 0);
  scene.add(player);

  const matSword = new THREE.MeshStandardMaterial({ color: 0xcccccc });
  const sword = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.2), matSword);
  sword.position.set(0, -0.5, 0);
  sword.visible = false;
  sword.castShadow = true;
  playerRightArm.add(sword);

  const fist = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
  fist.position.set(0, -0.6, 0);
  fist.visible = true;
  fist.castShadow = true;
  playerRightArm.add(fist);

  const claw = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.1), new THREE.MeshStandardMaterial({ color: 0xff00ff }));
  claw.position.set(0, -0.5, 0);
  claw.visible = false;
  claw.castShadow = true;
  playerRightArm.add(claw);

  let currentWeapon = "–ö—É–ª–∞–∫";

  function showDialogue(text, choices = [], callback = null) {
    isTalking = true;
    selectedIndex = 0;
    currentChoices = choices;
    currentCallback = callback;
    dialogueEl.innerHTML = `<div>${text}</div>` + choices.map((c, i) =>
      `<div class="choice${i === 0 ? ' selected' : ''}">${c}</div>`).join("");
  }

  function updateChoicesUI() {
    const elems = dialogueEl.querySelectorAll(".choice");
    elems.forEach((el, i) => {
      el.className = "choice" + (i === selectedIndex ? " selected" : "");
    });
  }

  function closeDialogue() {
    isTalking = false;
    currentChoices = [];
    currentCallback = null;
    dialogueEl.innerHTML = "";
  }

  document.addEventListener("keydown", e => {
    if (isTalking) {
      if (["w", "a", "arrowup"].includes(e.key.toLowerCase())) {
        selectedIndex = (selectedIndex - 1 + currentChoices.length) % currentChoices.length;
        updateChoicesUI();
      }
      if (["s", "d", "arrowdown"].includes(e.key.toLowerCase())) {
        selectedIndex = (selectedIndex + 1) % currentChoices.length;
        updateChoicesUI();
      }
      if (e.key === "Enter") {
        const choice = currentChoices[selectedIndex];
        if (currentCallback) currentCallback(choice);
        closeDialogue();
      }
    } else {
      if (e.key.toLowerCase() === "e") {
        const npc = npcs.find(n => n.group.position.distanceTo(player.position) < 2.5);
        if (npc) npc.talk();
      }
      if (e.key.toLowerCase() === "i") {
        if (!isTalking) {
          const choices = ["–ö—É–ª–∞–∫"];
          if (inventory.includes("–ö–æ–≥–æ—Ç—å")) choices.push("–ö–æ–≥–æ—Ç—å");
          if (inventory.includes("–ú–µ—á")) choices.push("–ú–µ—á");
          showDialogue("–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ä—É–∂–∏–µ:", choices, choice => {
            currentWeapon = choice;
            sword.visible = (choice === "–ú–µ—á");
            claw.visible = (choice === "–ö–æ–≥–æ—Ç—å");
            fist.visible = (choice === "–ö—É–ª–∞–∫");
          });
        }
      }

      if (e.key === " " && isOnGround) {
        velocityY = jumpStrength;
        isOnGround = false;
      }
    }
  });

  const npcs = [];
  let questGiven = false;
  let questComplete = false;
  let rewardGiven = false;
  let swordSold = false;

  function createNPC(x, z, color, talkFn) {
    const parts = createCharacter({ color, x, z });
    const npc = parts.group;
    npc.talk = talkFn;
    npc.castShadow = true;
    scene.add(npc);
    npcs.push({ group: npc, talk: talkFn });
  }

  createNPC(-5, 0, 0xffff00, () => {
    if (!questGiven) {
      showDialogue("–ü—Ä–∏–≤–µ—Ç, —É–±–µ–π –≤—Ä–∞–≥–∞ —É –≤–æ—Ä–æ—Ç!", ["–ü—Ä–∏–Ω—è—Ç—å", "–ü–æ–∑–∂–µ"], choice => {
        if (choice === "–ü—Ä–∏–Ω—è—Ç—å") questGiven = true;
      });
    } else if (questComplete && !rewardGiven) {
      showDialogue("–û—Ç–ª–∏—á–Ω–æ! –û—Ç–∫—Ä—ã–≤–∞—é –≤–æ—Ä–æ—Ç–∞!", ["–°–ø–∞—Å–∏–±–æ!"], () => {
        gold += 20;
        updateUI();
        gateOpen = true;
        obstacles.splice(obstacles.indexOf(gate), 1);
        rewardGiven = true;
      });
    } else if (questComplete && rewardGiven) {
      showDialogue("–¢—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª –Ω–∞–≥—Ä–∞–¥—É.");
    } else {
      showDialogue("–í—Ä–∞–≥ –µ—â—ë –∂–∏–≤!");
    }
  });

  createNPC(5, 0, 0xff8800, () => {
    if (!swordSold) {
      showDialogue("–ö—É–ø–∏ –º–µ—á –∑–∞ 10 –∑–æ–ª–æ—Ç–∞?", ["–ö—É–ø–∏—Ç—å", "–ù–µ—Ç"], choice => {
        if (choice === "–ö—É–ø–∏—Ç—å" && gold >= 10) {
          gold -= 10;
          inventory.push("–ú–µ—á");
          swordSold = true;
          updateUI();
        }
      });
    } else {
      showDialogue("–£ –º–µ–Ω—è –±–æ–ª—å—à–µ –Ω–µ—Ç –º–µ—á–µ–π.");
    }
  });
  function createHealthBar() {
    const bar = document.createElement("div");
    bar.style.position = "absolute";
    bar.style.width = "50px";
    bar.style.height = "6px";
    bar.style.background = "rgba(255,0,0,0.5)";
    bar.style.border = "1px solid red";
    bar.style.borderRadius = "3px";
    bar.style.overflow = "hidden";
    bar.style.display = "none";
    const fill = document.createElement("div");
    fill.style.height = "100%";
    fill.style.width = "100%";
    fill.style.background = "lime";
    bar.appendChild(fill);
    document.body.appendChild(bar);
    return { container: bar, fill: fill };
  }

  function createEnemy(x, z, color) {
    const parts = createCharacter({ color, x, z });
    const enemy = parts.group;
    enemy.castShadow = true;
    enemy.health = 3;
    enemy.maxHealth = 3;
    enemy.healthBar = createHealthBar();
    enemy.alive = true;
    enemy.alreadyChasing = false;
    scene.add(enemy);
    return enemy;
  }

  const enemy = createEnemy(0, -10, 0xff0000);
  const enemyInside = createEnemy(0, 25, 0xff00ff);

  let velocityY = 0;
  let isOnGround = false;
  const gravity = -0.02;
  const jumpStrength = 0.35;
  let isAttacking = false;
  let attackTimer = 0;

  document.addEventListener("mousedown", e => {
    if (!isTalking && e.button === 0) {
      if (!isAttacking) {
        isAttacking = true;
        attackTimer = 0.2;
      }
    }
  });

  function updateHealthBar(enemyObj) {
    if (!enemyObj.healthBar) return;
    const vector = enemyObj.position.clone();
    vector.y += 2.5;
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    enemyObj.healthBar.container.style.left = `${x - 25}px`;
    enemyObj.healthBar.container.style.top = `${y - 30}px`;
    const ratio = enemyObj.health / enemyObj.maxHealth;
    enemyObj.healthBar.fill.style.width = `${Math.max(0, ratio * 100)}%`;
    if (player.position.distanceTo(enemyObj.position) < 5) {
      enemyObj.healthBar.container.style.display = "block";
    } else {
      enemyObj.healthBar.container.style.display = "none";
    }
  }

  function takeDamage() {
    if (playerHealth > 0) {
      playerHealth--;
      updateHealthUI();
      redFlash.style.opacity = 1;
      setTimeout(() => redFlash.style.opacity = 0, 150);
      if (playerHealth <= 0) {
        showDialogue("–í—ã –ø–æ–≥–∏–±–ª–∏! –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.", []);
      }
    }
  }

  function chase(enemyObj) {
    const dist = player.position.distanceTo(enemyObj.position);
    if (dist < 5 && dist > 1.5) {
      const dir = player.position.clone().sub(enemyObj.position).normalize();
      enemyObj.position.add(dir.multiplyScalar(0.05));

      // –ü–æ–≤–æ—Ä–æ—Ç –≤—Ä–∞–≥–∞ –ª–∏—Ü–æ–º –∫ –∏–≥—Ä–æ–∫—É
      enemyObj.lookAt(player.position.clone().setY(enemyObj.position.y));

      if (!enemyObj.alreadyChasing) {
        enemyObj.alreadyChasing = true;
        enemyObj.healthBar.container.style.display = "block";
      }
    }
  }
  
  function aabb(boxA, boxB) {
    return (
      boxA.max.x > boxB.min.x && boxA.min.x < boxB.max.x &&
      boxA.max.y > boxB.min.y && boxA.min.y < boxB.max.y &&
      boxA.max.z > boxB.min.z && boxA.min.z < boxB.max.z
    );
  }

  const obstacles = [];
  function addObstacle(mesh) { obstacles.push(mesh); }

  const matFloor = new THREE.MeshStandardMaterial({ color: 0x228822 });
  const floor = new THREE.Mesh(new THREE.BoxGeometry(100, 1, 100), matFloor);
  floor.position.y = -0.5;
  floor.receiveShadow = true;
  scene.add(floor);
  addObstacle(floor);

  const matPlatform = new THREE.MeshStandardMaterial({ color: 0x8888ff });
  const platform = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 6), matPlatform);
  platform.position.set(0, 2, 5);
  platform.receiveShadow = true;
  scene.add(platform);
  addObstacle(platform);

  let gate = null;
  let gateOpen = false;
  function buildWall(x, y, z, w, h, d) {
    const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: 0x888888 }));
    wall.position.set(x, y, z);
    wall.castShadow = true;
    wall.receiveShadow = true;
    scene.add(wall);
    addObstacle(wall);
  }

  function buildCastle() {
    buildWall(0, 3, 30, 20, 6, 1);
    buildWall(-10, 3, 20, 1, 6, 20);
    buildWall(10, 3, 20, 1, 6, 20);
    buildWall(-6, 3, 10, 10, 6, 1);
    buildWall(6, 3, 10, 10, 6, 1);
    gate = new THREE.Mesh(new THREE.BoxGeometry(2, 5, 1), new THREE.MeshStandardMaterial({ color: 0x552200 }));
    gate.position.set(0, 2.5, 10);
    gate.castShadow = true;
    gate.receiveShadow = true;
    scene.add(gate);
    addObstacle(gate);
  }

  buildCastle();

  function getPlayerBox(pos) {
    return new THREE.Box3().setFromCenterAndSize(pos.clone().add(new THREE.Vector3(0, 1, 0)), new THREE.Vector3(1, 2, 1));
  }

  function collides(pos) {
    const box = getPlayerBox(pos);
    return obstacles.some(obj => {
      const other = new THREE.Box3().setFromObject(obj);
      return aabb(box, other);
    });
  }

  function animate() {
    requestAnimationFrame(animate);

    const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0, 1, 0)).normalize();
    const speed = 0.15;

    let moveX = 0, moveZ = 0;
    if (keys["w"]) { moveX += dir.x; moveZ += dir.z; }
    if (keys["s"]) { moveX -= dir.x; moveZ -= dir.z; }
    if (keys["a"]) { moveX -= right.x; moveZ -= right.z; }
    if (keys["d"]) { moveX += right.x; moveZ += right.z; }

    const move = new THREE.Vector3(moveX, 0, moveZ).normalize().multiplyScalar(speed);
    const pos = player.position.clone();

    const nextX = pos.clone().add(new THREE.Vector3(move.x, 0, 0));
    if (!collides(nextX)) player.position.x = nextX.x;

    const nextZ = player.position.clone().add(new THREE.Vector3(0, 0, move.z));
    if (!collides(nextZ)) player.position.z = nextZ.z;

    velocityY += gravity;
    const nextY = player.position.clone().add(new THREE.Vector3(0, velocityY, 0));
    if (!collides(nextY)) {
      player.position.y = nextY.y;
      isOnGround = false;
    } else {
      if (velocityY < 0) isOnGround = true;
      velocityY = 0;
    }

    player.rotation.y = yaw;

    if (isAttacking) {
      attackTimer -= 0.016;
      if (attackTimer <= 0) {
        isAttacking = false;
        let damage = 0.5;
        if (currentWeapon === "–ö–æ–≥–æ—Ç—å") damage = 1;
        if (currentWeapon === "–ú–µ—á") damage = 3;

        [enemy, enemyInside].forEach(en => {
          if (en.alive && player.position.distanceTo(en.position) < 2) {
            en.health -= damage;
            if (en.health <= 0) {
              en.alive = false;
              scene.remove(en);
              en.healthBar.container.remove();
              if (en === enemy) {
                inventory.push("–ö–æ–≥–æ—Ç—å");
                gold += 10;
                if (questGiven) questComplete = true;
              } else {
                gold += 50;
              }
              updateUI();
            }
          }
        });
      }
    }

    [enemy, enemyInside].forEach(en => {
      if (en.alive) {
        chase(en);
        updateHealthBar(en);
        if (player.position.distanceTo(en.position) < 2) {
          en.userData.attackTimer = (en.userData.attackTimer || 0) + 0.016;
          if (en.userData.attackTimer >= 1) {
            en.userData.attackTimer = 0;
            takeDamage();
          }
        } else {
          en.userData.attackTimer = 0;
        }
      }
    });

    if (gateOpen && gate.position.y < 10) {
      gate.position.y += 0.1;
    }

    const camX = player.position.x - Math.sin(yaw) * 5;
    const camY = player.position.y + 2 + Math.sin(pitch) * 5;
    const camZ = player.position.z - Math.cos(yaw) * 5;
    camera.position.set(camX, camY, camZ);
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  updateUI();
  updateHealthUI();
  animate();
</script>
</body>
</html>
